/*
 * display_drv.c
 *
 *  Created on: Aug 13, 2017
 *      Author: Joonatan
 */

#include "display_drv.h"
#include <driverlib.h>
#include "spi_drv.h"
#include "register.h"

#define NUMBER_OF_PAGES 8u
#define NUMBER_OF_COLUMNS 128u
#define NUMBER_OF_ROWS (NUMBER_OF_PAGES * 8u)

#define GET_SEGMENT(column) ((column) >> 3u) //Divided by 8, since there are 8 columns per segment.
#define GET_FIRST_COLUMN(segment) ((segment) << 3u) //Multiplied with 8, returns the first column index of a segment.

Private const U8 girl_bmp[] =
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x70,
0x94,0x6A,0xAA,0xF4,0x5A,0xF4,0x9E,0xFA,0xDC,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
0xFE,0xFE,0xF6,0x7C,0xEA,0x56,0xFE,0xBE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
0xFE,0xFE,0xFE,0xFE,0xDE,0xFE,0x7A,0xEE,0xDE,0x76,0xDE,0xB6,0x7E,0xDC,0xFE,0xBA,
0xF4,0xEA,0xD2,0xAC,0xD8,0x50,0xA0,0x60,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0xCB,0xF5,
0xBE,0xEB,0xF5,0xBE,0xED,0xB7,0xDF,0x7B,0xDF,0xFF,0xFF,0xFF,0xBF,0xFF,0xFF,0xFF,
0xBF,0x3F,0xAF,0x0F,0x2B,0x0F,0x03,0x0F,0x03,0x0D,0x17,0x0F,0x1F,0x2F,0x1F,0x5F,
0xBF,0x7F,0xBE,0x7F,0xFA,0x6F,0xFB,0xDD,0xFF,0x7B,0xED,0xF7,0xDF,0xFD,0x76,0xFF,
0xEA,0xBF,0x5D,0xFF,0x77,0xDF,0xF6,0xBD,0xEA,0xBD,0xEA,0xB6,0x68,0xD8,0xA0,0x50,
0xA0,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x7D,0xFF,0xFD,
0xFF,0xB7,0xFE,0xF5,0xFF,0xFE,0xFF,0xAF,0x7B,0xD6,0xBD,0xC7,0x79,0x2F,0x03,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x05,0x01,0x17,0x0B,0x55,0x3F,0x6F,0x5D,0xF7,0xBF,0xFF,0xFF,0xFD,
0xF7,0xBF,0xFF,0xFD,0xF7,0xFD,0xF7,0xDF,0xFE,0x7B,0xF6,0xFF,0xFD,0xBF,0xEA,0xFF,
0xEA,0xDD,0xFA,0xAD,0xF5,0xEA,0xEA,0xD4,0xD0,0xA8,0xA8,0x50,0xA0,0x50,0xA0,0xC0,
0xA0,0x40,0x40,0xC0,0x40,0x40,0x80,0xC0,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x7F,0xFF,
0xFF,0xFD,0xFF,0xFF,0xFF,0xFF,0xFE,0xAB,0x54,0xFF,0x0A,0xB5,0x8A,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x10,0x58,0x4C,0xA4,0x12,
0x29,0x10,0x7C,0x28,0x0C,0xC8,0x18,0x18,0x15,0x28,0x07,0x18,0x25,0x87,0x1F,0x7F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xF7,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,
0xFE,0x7F,0x7D,0xBF,0x7D,0x3F,0xBD,0x3E,0x3B,0x7D,0x2E,0x3D,0x2C,0x36,0x3C,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x1F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB,0xFF,0x5D,0xB9,0x3D,0x6D,0x4E,0x8D,0x96,
0x5E,0x04,0x4A,0x20,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
0x00,0x02,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x44,0x12,0xA8,0x01,
0x57,0x5F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xB7,0xDF,0xFF,0xFF,0xFF,0xBF,0xBF,0x7F,0xBF,0x7E,0xAF,
0x9E,0xBF,0x1D,0x3E,0x3E,0x5A,0x3C,0xAC,0x38,0x58,0xA8,0x10,0x50,0x10,0x40,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x5F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFA,0xE0,0x80,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x48,0x00,0x54,0x00,0x00,0x10,0x02,0x00,0x00,0x04,0x80,0x15,0x00,0xAA,0x00,
0x55,0x40,0xF5,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xBF,0x2F,0xEB,0xDF,0x7F,0xAF,0x7F,0x5E,0x3B,0xEA,0x2D,0x50,0x84,0x28,
0x80,0x10,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,
0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x80,0x00,0x00,0x00,0x40,0x40,0x40,0x65,0x40,0x72,
0x50,0x30,0xB8,0xB0,0x98,0x40,0xAC,0x00,0x54,0x02,0x50,0x04,0x50,0xC9,0xD2,0x68,
0x5D,0x5F,0xBF,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x5F,
0xF7,0x1F,0x5E,0x35,0x6B,0xC4,0x93,0x08,0x42,0x09,0x22,0x00,0x08,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x07,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFC,0xF8,0xF9,0xF0,0xF1,0xE2,
0xC1,0xE5,0xC2,0xD1,0xC4,0xD1,0x62,0x50,0xD0,0x74,0xD9,0xAC,0xDF,0x57,0x6A,0x55,
0xEA,0x55,0xAA,0x55,0xD5,0xB4,0x4B,0xB4,0xDB,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xB9,
0x02,0x54,0x09,0x80,0x25,0x00,0x09,0x01,0x22,0x04,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/*****************************************************************************************************
 *
 * Type definitions.
 *
 *****************************************************************************************************/
typedef struct
{
    FillPatternType id;
    U8 number_of_segments;
    const U8 * pattern;
} FillPattern;


/* TODO : Some of these could be replaced with macros, or inline functions. */

/*****************************************************************************************************
 *
 * Private function prototypes
 *
 *****************************************************************************************************/

Private void drawImage(Point p, Size s, const Bitmap * bmp);
Private void drawPattern(Point p, Size s, const FillPattern * patternType);
Private void disp_command(U8 cmd, Boolean reg_select);
Private void set_page_address(U8 page);
Private void set_column(U8 column);
Private void write_data(U8 data);
Private void display_reset(void);
Private void display_empty(void);


/*****************************************************************************************************
 *
 * Private variable declarations.
 *
 *****************************************************************************************************/

Private U8 priv_display_buffer[NUMBER_OF_COLUMNS][NUMBER_OF_PAGES];
Private U8 priv_split_buffer[NUMBER_OF_COLUMNS]; //Used for splitting image data between pages.

Private U16 priv_page_validity_bits[NUMBER_OF_PAGES]; //Each page is divided into 16 virtual segments.

//Should be some kind of letter.
Private const U8 test_bitmap_data[] = {0x00u,0x7Eu,0x11u,0x11u,0x11u,0x7Eu};

Private const Bitmap test_bitmap =
{
 .bmp_size = (Size){8u, 6u },
 .bmp_data = test_bitmap_data,
};

Private const Bitmap test_girl_bitmap =
{
 .bmp_size = (Size) {64u, 128u},
 .bmp_data = girl_bmp,
};



//Display patterns.


Private const U8 priv_white_pattern = 0x00u;
Private const U8 priv_black_pattern = 0xffu;
Private const U8 priv_gray_pattern[2u] = {0xAAu, 0x55u };

Private const FillPattern priv_fill_patterns[NUMBER_OF_PATTERNS] =
{
     {PATTERN_WHITE, 1u, &priv_white_pattern    },
     {PATTERN_BLACK, 1u, &priv_black_pattern    },
     {PATTERN_GRAY,  2u, priv_gray_pattern      }
};




volatile Boolean isDisplayReady = FALSE;

/* Set up A0 pin for display. */
Public void display_init(void)
{
    //Set the chip select pin as high initially.
    memset(priv_display_buffer, 0x00u, sizeof(priv_display_buffer));
    memset(priv_page_validity_bits, 0x0000u, sizeof(priv_page_validity_bits));

    display_reset();
    set_cs_pin(1u);
}

//Should be called after display_init.
Public void display_start(void)
{
    //Low CS, means that it is active.
    set_cs_pin(0u);

    //Display start line set.
    disp_command(0x40u, FALSE);

    //Set ADC in reverse
    disp_command(0xA1u, FALSE);
    //Common output mode select
    disp_command(0xC0u, FALSE);

    //display normal
    disp_command(0xA6u, FALSE);

    //LCD bias set
    disp_command(0xA2u, FALSE);

    //Power control set
    disp_command(0x2Fu, FALSE);

    //Booster ratio set.
    disp_command(0xF8u, FALSE);
    disp_command(0x00u, FALSE);

    //Contrast set.
    disp_command(0x27u, FALSE);
    disp_command(0x81u, FALSE);
    disp_command(0x10u, FALSE);

    //Static indicator set.
    disp_command(0xACu, FALSE);

    //Turn on display.
    disp_command(0x00u, FALSE);
    disp_command(0xAFu, FALSE);

    delay_msec(200);
    //Turn on all points.
    disp_command((0xA4u | 0x01u), FALSE);
    display_empty();
    delay_msec(2000);
    //Turn off all points.
    disp_command(0xA4u, FALSE);

    //TODO : Probably should remove this delay from here.
    delay_msec(500);

    //display_drawBitmap(&test_bitmap, (Point){0,0});
    display_drawBitmap(&test_girl_bitmap, (Point){0,0});

    isDisplayReady = TRUE;
}


/* TODO : Implement this. */
Public void display_cyclic_50msec(void)
{
    //Redraw display.
    U8 page, column, seg, prev_column;
    if (isDisplayReady)
    {
        for (page = 0u; page < NUMBER_OF_PAGES; page++)
        {
            if (priv_page_validity_bits[page] > 0u)
            {
                //Redraw page.
                set_page_address(page);
                prev_column = 0xffu;

                for (seg = 0u; seg < 16u; seg++) //Iterate over each segment.
                {
                    if ((priv_page_validity_bits[page] >> seg) & (U16)0x01u)
                    {
                        column = GET_FIRST_COLUMN(seg);
                        if (column != prev_column)
                        {
                            set_column(column);
                        }
                        for (; column < GET_FIRST_COLUMN(seg + 1u); column++)
                        {
                            //write_data(priv_display_buffer[column][page]);
                            write_data(~priv_display_buffer[column][page]);
                        }
                        prev_column = column;
                    }
                }

                priv_page_validity_bits[page] = 0x0000u;
            }
        }
    }
}


Public void display_drawBitmap (const Bitmap * bmp, Point location)
{
    if (bmp != NULL)
    {
        drawImage(location, bmp->bmp_size, bmp);
    }
}


//Draw rectangle into frame buffer and invalidate pages that contain the rectangle.
Public void display_fillRectangle(Point p, Size s, FillPatternType patternType)
{
    if (patternType < NUMBER_OF_PATTERNS)
    {
        drawPattern(p, s, &priv_fill_patterns[patternType]);
    }
}


Public void display_clear(void)
{
    U8 x, y;
    for (x = 0u; x < NUMBER_OF_PAGES; x++)
    {
        priv_page_validity_bits[x] = (U16)0xffffu; //Invalidate whole display.
        for(y = 0u; y < NUMBER_OF_COLUMNS; y++)
        {
            priv_display_buffer[y][x] = 0x00u;
        }
    }
    //TODO : Clearing validity bits should be replaced by a macro.
}


/*****************************************************************************************************
 *
 * Private Functions
 *
 *****************************************************************************************************/

Private void drawPattern(Point p, Size s, const FillPattern * pattern_ptr)
{
    U8 curr_page, bottom_page, top_page;
    U8 column, right_column, bottom_row;
    U8 mask, y_offset;

    U8 left_segment, right_segment, ix;
    U8 pattern_segment = 0u;

    //TODO : Might need to check if patternType is in range.
    const U8 * data;
    U8 value;

    data = pattern_ptr->pattern;

    if ((p.x < NUMBER_OF_COLUMNS) && (p.y < NUMBER_OF_ROWS))
    {
        bottom_row = p.y + s.height - 1;
        right_column = p.x + s.width;

        bottom_page = bottom_row >> 3u; //Divide with 8
        top_page = p.y >> 3u; //Divide with 8

        if (bottom_page >= NUMBER_OF_PAGES )
        {
            bottom_page = NUMBER_OF_PAGES - 1;
        }

        if (right_column >= NUMBER_OF_COLUMNS)
        {
            right_column = NUMBER_OF_COLUMNS - 1;
        }

        left_segment = GET_SEGMENT(p.x);
        right_segment = GET_SEGMENT(right_column);

        y_offset = p.y % 8u;

        for (curr_page = top_page; curr_page <= bottom_page; curr_page++)
        {
            mask = 0xffu;
            if (curr_page == top_page)
            {
                mask = mask << y_offset;
            }

            if (curr_page == bottom_page)
            {
                mask &= (0xffu >> (7u - (bottom_row % 8u)));
            }

            pattern_segment = 0u;

            for (column = p.x; column <= right_column; column++)
            {
                //We are drawing a pattern.
                value = *data;
                if (++pattern_segment >= pattern_ptr->number_of_segments)
                {
                    pattern_segment = 0u;
                }
                data = pattern_ptr->pattern + pattern_segment;

                priv_display_buffer[column][curr_page] |= (mask & value);
            }

            //Invalidate page segments.
            for (ix = left_segment; ix <= right_segment; ix++)
            {
                priv_page_validity_bits[curr_page] |= (U16)((U16)1u << ix);
            }
        }
    }
}


//Draw an image in a rectangular area.
Private void drawImage(Point p, Size s, const Bitmap * bmp)
{
    U8 curr_page, bottom_page, top_page;
    U8 column, right_column, bottom_row;
    U8 mask, y_offset;

    U8 left_segment, right_segment, ix;

    //TODO : Might need to check if patternType is in range.
    const U8 * data;
    U8 value;

    //We start drawing a bitmap.
    data = bmp->bmp_data;

    if ((p.x < NUMBER_OF_COLUMNS) && (p.y < NUMBER_OF_ROWS))
    {
        bottom_row = p.y + s.height - 1;
        right_column = p.x + s.width - 1;

        bottom_page = bottom_row >> 3u; //Divide with 8
        top_page = p.y >> 3u; //Divide with 8

        if (bottom_page >= NUMBER_OF_PAGES )
        {
            bottom_page = NUMBER_OF_PAGES - 1;
        }

        if (right_column >= NUMBER_OF_COLUMNS)
        {
            right_column = NUMBER_OF_COLUMNS - 1;
        }

        left_segment = GET_SEGMENT(p.x);
        right_segment = GET_SEGMENT(right_column);

        y_offset = p.y % 8u;

        for (curr_page = top_page; curr_page <= bottom_page; curr_page++)
        {
            mask = 0xffu;
            if (curr_page == top_page)
            {
                mask = mask << y_offset;
            }

            if (curr_page == bottom_page)
            {
                mask &= (0xffu >> (7u - (bottom_row % 8u)));
            }

            for (column = p.x; column <= right_column; column++)
            {
                //We are drawing a bitmap.
                //We need to extract the value to be written to the display.
                value = (*data) >> y_offset;
                if(curr_page != top_page)
                {
                    value |= priv_split_buffer[column]; //Should contain the top bits for the bitmap image. If it is top page, then these bits are ignored anyway.
                }
                if (y_offset > 0)
                {
                   priv_split_buffer[column] = (*data) << (7u - y_offset);
                }

                priv_display_buffer[column][curr_page] |= (mask & value);
                data++;
            }

            //Invalidate page segments.
            for (ix = left_segment; ix <= right_segment; ix++)
            {
                priv_page_validity_bits[curr_page] |= (U16)((U16)1u << ix);
            }
        }
    }
}


//TODO : Replace this with macro.
Private inline void disp_command(U8 cmd, Boolean reg_select)
{
    spi_transmit_byte(cmd, reg_select);
}


Private inline void set_page_address(U8 page)
{
    disp_command(0xB0u | (page & 0x0fu), FALSE);
}


Private inline void write_data(U8 data)
{
    disp_command(data, TRUE);
}


Private inline void set_column(U8 column)
{
    //Set column MSB.
    disp_command(0x10u | (column >> 4u),  FALSE);
    //Set column LSB.
    disp_command(column & 0x0fu, FALSE);
}


Private void display_reset(void)
{
    set_disp_reset_pin(0u);
    delay_msec(100);
    set_disp_reset_pin(1u);
    delay_msec(100);
}

//This is more of a HW function, maybe it should still remain, but not be used when wanting to clear the framebuf instead.
Private void display_empty(void)
{
    U8 ix;
    U8 yx;

    for (ix = 0u; ix < NUMBER_OF_PAGES; ix++)
    {
        set_page_address(ix);
        set_column(0);
        for (yx = 0u; yx < NUMBER_OF_COLUMNS; yx++)
        {
            write_data(0x00u);
        }
    }
}





